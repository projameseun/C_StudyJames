#include <iostream>

//#pragma pack(1)	패딩없애는 방법
class CTemp
{
	int a;
	int b;
	char c;
	char d;
	double e;
	short f;
};
//#pragma pack()

class CParent
{
private:
	int m_i;

protected:
	int m_k;	//둘은 엄연히 다르다 부모 멤버변수

public:
	 void Func()	//정적바인딩	
	{
		std::cout << "부모 함수" << std::endl;
	}

public:
	int GetInt()
	{
		return m_i;
	}

	void SetInt(int _i)
	{
		m_i = _i;
	}

public:
	CParent() :
		m_i(0),
		m_k(0)
	{
		std::cout << "부모 생성자 호출" << std::endl;
	}
	~CParent() 
	{
		std::cout << "부모 소멸자 호출 " << std::endl;
	}
	
};

class CChild : public CParent
{
public:
	float m_f;
	int m_k;		//둘은 엄연히 다르다 자식멤버변수

public:
	void Func() 	//정적바인딩
	{
		std::cout << "자식 함수" << std::endl;
		
	}

public:
	int ParentGetInt()
	{
		return m_k;
	}

public:
	CChild() :
		m_f(0.f),
		CParent()
	{
		std::cout << "자식 생성자 호출 " << std::endl;
	}
	~CChild()
	{
		std::cout << "자식 소멸자 호출" << std::endl;
	}
};

int main()
{
	size_t iSize = sizeof(CTemp);

	//클래스의 크기
	//제일 큰 변수의 메모리를 기준으로 잡아 나간다.
	//이 이유는 패딩바이트 때문에 그렇다
	//패딩 바이트란 클래스,구조체에 패딩 바이트를 추가하여 CPU접근을 더 용이하게 해 주는 것을 말한다
	//자칫 공간 낭비될수 있는 패딩 공간을 확보하면서 메모리의 크기를 맞추는데 이유는 캐시hit율을 높이고 CPU연산 횟수를 줄이기 위해서이다.
	//32비트는 CPU가 한번에 4바이트 , 64비트는 CPU가 8바이트를 읽어 들이는데  
	//패딩바이트를 사용하지 않게되면 byte가 남게되어 연산을 두번하게 되는 현상이온다. 
	//컴퓨터는 4,8바이트식으로 정렬된 상태로 처리하는것을 선호하게 되고 비정렬 데이터는 성능 저하를 유발시킬수 있다.
	//핵심 CPU는 데이터를 읽고 쓸때 메모리정렬이 맞지않으면 성능이 저하가 된다 
	//그 이유는 위에설명 한것처럼 데이터를 두 번읽거나 추가작업을 해야 하므로 떨어진다.


	//상속
	//클래스간에 부모와 자식의 관계를 형성 시켜줄수 있는 기능이다.
	//A클래스와 B클래스가 있을때 B가 A를 상속받고 있다면
	// A를 부모클래스(기본클래스) B를 자식클래스(파생클래스)라고 부른다.
	// B는 상속받고 A의 멤버함수를 물려받아 사용할수 있게 된다.
	// 이때 A에, priavte로 되어 있다면 자식에서도 접근 할수 없다.


	//자식을 호출했을때
	//초기화는 부모부터 일어나지만 
	//호출순서는 자식부터 일어난다 헷갈려서는 안된다.
	//정리하면 
	// 생성자 호출순서 자식 -> 부모
	//생성자 실행순서 부모 - > 자식
	//소멸자 실행순서 자식 -> 부모

	//자식 또는 부모 클래스는 상속관계에서 다른클래스의 멤버를 초기화 할수없다  본인클래스는 본인이 초기화를 한다.

	//다형성: 상속 관계에 있어서 클래스들은 서로 형변환이 가능하다.
	//자식 클래스를 부모클래스로 형변환 가능하고
	//부모 클래스를 자식클래스로 형변환이 가능하다.
	//자식 -> 부모 형변환 : 업캐스팅
	//부모 -> 자식 형변환 : 다운캐스팅

	//업캐스팅은 안전한 형변환이다.
	//ex) CParent* pCp = &ch; 포인터는 주소를 가리키는데 이때 부모pCp는 부모클래스 주소를 갖고 있다 ch변수는 부모 자식을 둘다 갖고 있기때문에
	//그 주소로 접근이 가능하기 때문에 안전하다 반대로 
	//다운캐스팅은 안전을 보장할수 없다
	//ex)CChild* pCh = &cp; 이런 경우에는 pCh는 자식클래스를 갖고있는데 이때 cp변수는 부모크기만 갖고있기때문에 자식에 접근이 불가능하다 

	//다운캐스팅,업캐스팅
	//생성자( 복사생성자(깊은복사,얕은복사)
	//오버라이딩, 가상함수 

	//CParent cp;
	CChild ch;

	CParent* pCp = &ch;

	//CChild* pCh = &cp;

	//오버라이딩
	//상속에서만 사용이가능하다.
	//상속받은것들중에 새로운 기능을 추가하거나 다른 기능을 하도록 변경하는것을 오버라이딩이라고한다.
	//또한 이미 부모클래스에 정의된 함수와 같은이름을 자식클래스에서 재정의할때 가능하다
	
	//override는 부모가 갖고있는 함수를 자식이 똑같이 사용한다고 override는아니다
	//정확히는 부모가 가상함수를 갖고있을때 자식이 똑같은 함수를 갖고있을때 override가 된것이다
	//이는 다형성이라고 부를수 있다.

	//오버라이딩을 사용하는 이유 
	//자식의 재정의에 핵심이 있다
	//게임으로 예를든다면
	//SKILL이라느 부모클래스가 있고 
	//자식쪽에 수많은 스킬을 넣었을때 
	//자식쪽마다 모두 다른 기능을 쓰고 싶을때가 있을것이다 SKILL는 본체는 같지만 기능은 다다르게 사용할려고 사용한다 
	//결국 SKILL을 통하는건 같지만 결과값은 모두 종류마다 다를것이다.
	//어떤 한가지 클래스가 있지만 그기본기능을 가진 자식들은 모두 다양하게 결과값을 다르게 하고싶기때문에 이럴때 재정의함으로써 오버라이딩을 사용한다.
	//이는 정확히는 다형성구현에서 사용을 하게 된다.
	//결론은 상속받은 클래스에서 부모클래스의 함수를 재정의함으로써 동일한 인터페이스를 사용하면서도 자식클래스마다 다른 동작을 사용할수 있게 만들어주는게 핵심이다.
	//코드의 유연성: 게임 개발은 변화가 매우빠른대 부모클래스를 (기본틀)은 변경하지 않고 업데이트될때마다 새로운 자식클래에서 새로운 기능을 추가할수 있고 수정할수있다
	//상속 구조를 재사용 함으로써 각기 다른방식으로 행동 할수 있게 만들수 있다
	//동적 바인딩이 가능하다 
	//c++에서 virtual 키워드를 사용하여 동적으로 호출을 하게되는데
	//이때 실시간 상황에서 특정 함수를 호출할지를 런타임에서 결정하게 할수 있게해준다.
	//예를들어 attack()함수가 호출되면 각각의 캐릭터가 자신만의 공격방식을 실행할수 있게해준다.

	//바인딩이란 연결이라는 의미랑 비슷한대
	//함수호출 과 함수의 실체 구현을 연결하는 과정을 의미한다 
	
	
	//동적바인딩 ->> 컴파일 이아닌 런타임에 결정되는 방식이다 
	//주로 가상함수에서 발생하며, 실행중에 어떤 함수가 호출될지 결정한다
	
	//정적바인딩 -> 컴파일에서 결정이 난다  Undefine behavior이 일어날수있다.
	//보통 가상함수가 아닌 일반함수로 선언된 함수에서 발생한다.

	

	int iNumber = 0;

	iNumber += ch.GetInt();	//get함수를 사용하여서 private를 가져올수있다. 

	ch.SetInt(100);		//set함수를 사용해서 private를 접근할수 있다.

	pCp->Func();


	//ch.m_k
	
	//ch.Func();		//자식쪽에 재정의되있을때 (overrding) 자식이 호출이되고 만약에 자식에 똑같은 함수가 재정의 되어 있지않으면 부모가 호출된다.
	//.CParent::Func();		//강제로 부모를 호출할때 

	
	return 0;
}