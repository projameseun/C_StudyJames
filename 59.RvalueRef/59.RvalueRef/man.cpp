#include <iostream>



/*
	r_value, l_value

	•lvalue
	메모리 주소를 갖고 있으며, 참조(주소)를 통해 접근할 수 있는 값입니다.
	변수, 배열 요소, 객체 등은 모두 lvalue입니다.

	int a = 10; // a는 lvalue
	a = 20;   // a는 lvalue

	•rvalue
	임시 값으로, 메모리 주소가 없거나 직접적으로 참조할 수 없는 값입니다.
	주로 연산 결과나 리터럴 등이 rvalue입니다.

	int b = a + 5; // a + 5는 rvalue
	b = 30;      // 30은 rvalue
*/

//3.참조를 반환하는 함수 vs 값을 반환하는 함수

int x = 10;


int f1()
{
	return x;	//10을 리턴
}

int& f2()
{
	return x;	//x의 참조(별명)을 반환한다
}


//5.r-value는 상수인가?

class Point
{
private:
	int m_x;
	int m_y;
public:
	Point()
	{

	}
	Point(int x, int y) : m_x(x), m_y(y)
	{
		
	}

public:
	void Set(int x, int y)
	{
		this->m_x= x;
		this->m_y = y;
	}

	Point CreatePoint(int x, int y)
	{
		return Point(x, y);
	}

};





int main()
{
	int v1 = 0 , v2 = 0;
	
	v1 = 10;	//v1 lvalue
	//10 = v1;	//error
	v2 = v1;	//lvalue 양쪽에 다위치하는 l-value

	//l-value는 양쪽 다 위치할수 있는 값이기도 하다

	//조금쉽게 정리해보면
	//r-value의 특징은 등호의 오른쪽에만 올 수 있는값
	//l-value의 특징은 등호의 양쪽 모두 올수 있는 값이기도 하다.
	
	/*
		l-value								|				r-value
		등호(=)의왼쪽에 올수있다				|	등호(=)의 왼쪽에 올수 없다
		이름이 있고 단일식을 벗어나 사용 가능	|   이름이 없고, 단일식에만 사용가능
		주소 연산자로 주소를 구할수 있다		|	주소 연산자로 주소를 구할 수 없다.
		참조를 반환하는 함수					|	값을 반환하는 함수 
		문자열 리터럴								실수/정수 리터럴
												임시 객체(함수 리턴값)
	*/

	//1.이름과 단일식
	int a = 0, b = 0;
	a = 10;

	//a는 이름도 있고 메모리를 차지하고 있으므로 변수이다 
	//a를 a=10 처럼 다른 표현식에서 다시 접근도 가능하다는것이다.
	//이는 "이름이 있고 단일식을 벗어나 사용가능" 이라고 말할수있고 적합하기때문에 a는 l-value이다.

	//10 = a;
	//리터럴 상수 10은 이름이 없다 이런 리터럴 상수의 경우 메모리를 할당 받지 않고
	// 코드 메모리의 어샘블리 레벨에서 10이라고 적혀잇을뿐이다.
	// 데이터 메모리가 없으니 그에 따른 이름도 없고 다른표현식에서 다시 사용하는것도 불가능하기때문에 10은 r-value라고 할수 있다.
	
	//2.변수의 주소 
	int* p1 = &a;	//l_value
	//int* p2 = 10;	//r_value
	//a는 메모리를 할당받고 있기때문에 주소를 구할수 있다.
	//하지만 리터럴 상수 10은 코드 메모리 어딘가 어셈블리레벨에 위치하고 있으므로 할당 받은 메모리가 없다
	//당연히 주소도 구할수 없다. 10은 r-value에 적합하다.

	//3.참조를 반환하는 함수 vs 값을 반환하는 함수
	//f1() = 20;		//10 = 20 error
	f2() = 20;		//x = 20;

	//결론적으로 참조를 반환하게되면 등호의 왼쪽에 올수 있는 l-value가 되고,
	//값을 반환하게되면 r-value가 된다.

	//4.상수는 r-value인가?
	
	const int iNumber = 10;
	//iNumber = 20;	//error
	
	//상수 iNumber는 다른 표현식에서 20이라는 값을 다시 대입하다 에러를 발생한다
	//하지만 iNumber경우에는 이름도 가지고 있고, 다른표현식에서 이름을 이용해서 다시 사용이 가능하다(값을 변경하지는 못하지만 읽을수는 있다)
	//심지어 변수의 주소도 구할수 있다 이런것 l-value의특징이다
	//위와 같이 상수는 r-value가 아니라 l-value이다.
	//c++에서는 const lvalue 또는 const-qualified lvalue라고 한다

	//5.r-value는 상수인가?
	Point pt;

	pt.CreatePoint(1, 2).Set(10, 20);

	//r-value는 값을 변경할수 없으므로 상수라고 오해하기 쉽다. 하지만 
	//임시위에 코드처럼 객체의 멤버함수 등을 호출해 값을 수정할수 있다.
	//r-value는 등호의 왼쪽에 못오는것이지 상수는 아니다.

	//리터럴
	//실수나 정수의 리터럴 r-value
	//문자열의 리터럴은 l-value이다.

	//10 = 20;
	//"aa"[0] = 'x' //error
	//std::cout << "ab"[1] << std::endl;

	//10 =20 같은경우에는 r-value이기때문에 왼쪽에 올수없고 에러가 발생한다
	//"aa" 는 l-value인데 왜 에러가 발생했을까?
	//aa의 정확한 타입은 const char[3]이다 위에서 발생한 에러는 l-value가 아니라서가 아니라 const한정자 때문에 값을 수정 할수 없었던것이다.

	//표현식이란?
	//하나의 값을 만들어내는 코드의 집합

	//int n = 3;
	//n + 2 * 3 = 10;
	//위에 n은 3이다 이것은 표현식이다. 
	//n+2 는 5라는 값이다 이것또한 표현식이다
	//n +2 * 3은 9라는 값이 된다 이것도 표현식이다.
	//이렇게 표현식은 하나의 값을 만들어 내는 코드의 집합이다, 
	// 즉 표현식은 값을산출한다 또는 표현식의 결과가 값이다 라는말이다.
	//l-value,r-value를 판단하는것은 이런표현식의 등호의 왼쪽에 올수 있느냐 그렇지 않느냐는것이다.


	//r-value레퍼런스
	//c++에서는 레퍼런스 라는 &연산자를 이용해 또 다른 이름으로 같은 변수를 참조 할수 있다

	int v = 0;
	
	int& r1 = v;		//ok
	//int& r2 = 10;		//error
	//위와같이 레퍼런스는 r-value를 참조하게되면 컴파일  에러이다. r-value는 참조할수 없다.(일반참조 int&는 r-value를 참조 할수 없지만
	//,const int&는 r-value를 참조할수있다.


	const int& r3 = v;	//ok
	const int& r4 = 10;	//ok

	//위와같이 const레퍼런스의 경우에는 l-value, r-value모두 가리킬수 있다.
	
	//c++11이전에는 l-value만을 참조, l-value와 r-value모두를 가리킬수 있는 레퍼런스는 있지만(const-lvalue)
	//r-value만을 가리킬수 잇는 무언가는 없었따 
	//그래서 c++11부터는 r-value만을 가리킬수 있는 레퍼런스(&&)를 추가 하였다.

	//int&& r5 = v;		//error
	int&& r6 = 20;		//ok
	
	//r-value레퍼런스 특징은 일반 레퍼런스와 달리 r-value를 가리킬때는 아무런 문제가 없지만
	//l-value를 가리케되면 컴파일 에러가 발생한다.

	return 0;
}