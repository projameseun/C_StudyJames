#include <iostream>
#include "LinkedList.h"

int main()
{
	/*
		배열과 링크드리스트 

		--배열--
		장점: 인덱스가 존재하여서 인덱스로 빠르게 접근이 가능하다
		배열은 연속된 메모리 블록에서 저장되므로 포인터를 위한 추가 메모리(동적할당)가 필요하지 않는다
		이는 오버헤드가 적다는 것을 말한다. 


		삽입: 배열은 중간에 만약에 어떤 데이터를 추가하기 위해서는 해당위치의 모든 요소를 한 칸씩 뒤로 밀어야 된다
		예를들어 1 2 4 5 가 있다면 이를 위해서 4 5를 뒤로 밀어야되고 그안에 넣어줘야되는 상황이 온다
		
		삭제 : 배열의 중간요소에 삭제를 하게 된다면 해당 위치의 모든 요소를 앞으로 한칸씩 당겨줘야된다. 

		--링크드리스트---
		삽입 : 노드를 삽입하려는 위치를 찾은 후 새로운 노드를 생성하고 포인터를 조정해 주면된다.
		예를들어 1 2 4 5 가 있는데 2 와 4사이에 3을 삽입하려면 새로운 노드를 추가해주면 된다.
		위치를 찾는데는 처음부터 가야되서 시간이 걸리기는 한다.

		삭제 : 삭제할려는 노드의 이전 노드의 포인터를 삭제할 노드의 다음 노드로 변경하면 된다.
		예를들어 1 2 3 4 5 에서 3을 삭제할려면 2의 다음 포인터 4를 설정하면된다.  


		오버헤드란?
		주어진 작업을 수행하기 위해 추가로필요한 메모리양을 말한다
		예를들어 10초 걸리는 기능이 간접적인 원인으로 20초걸린다면 오버헤드는 10초가 되는것이다
		==================================================================================
		메모리 오버헤드
		---배열----
		배열의 경우 메모리 오버헤드가 거의 없다 이유는 연속된 메모리 블록을 사용하고 추가로 필요한 메모리가 거의 없기 때문이다

		----링크드 리스트---
		각 노드는 데이터뿐만 아니라 다음 노드를 가리키는 포인터를 저장해야된다.
		예를들어 4바이트 정수 데이터를 저장하는 배열은 요소당 4바이트가 필요하지만 동일 한ㅌ 데이터를 저장하는
		링크드리스트는 데이터4 + 포인터4 가 필요해서 8바이트가 필요하다


		시간오버헤드
		배열 
		접근은 매우빠르지만 (인덱스때문에) 삽입과 삭제는 평균적으로 많이 소요 될수있다 
		이유는 한가지를 중간에 삭제하고 삽입하기위해서는 나머지 데이터들이 밀리거나 땡겨질수 있기 때문이다.

		링크드리스트
		삽입 삭제는 노드의 포인터만 변경하면 되므로 빠르게 수행할수 있따
		하지만 접근할때는 처음부터 순차적으로 탐색해야 되므로 시간이 걸릴수 있다.

		=====================================================
		가변배열은 배열처럼 힙메모리에 메모리를 연속적으로 잡는게 특징이다

		링크드리스트는 힙영역에 메모리가 띄어져있다.
		띄어져있다면 그다음 주소에 접근을 못할거 같지만
		첫 위치를 head  마지막 위치를 tail로 만드는데
		예를들어 
		head에 데이터 100이 있다고 가정하자 근데 노드는 다음주소를 가르키는 포인터도 갖고있다 그래서
		띄어져있어도 다음 주소를 알기때문에 접근이 가능하다.
		결론적으로 하나의 노드는 데이터 + 포인터(주소)두가지를 갖고있다 
		32비트기준으로 int 데이터를 만든다면 데이터4byte + 포인터 4byte 총 한노드당 8byte가 필요하다.
		데이터하나를 저장하는걸 일반적으로 노드라고 부른다.


	*/

	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

	FLinkedList list = {};

	InitList(&list);

	PushBack(&list, 100);
	PushBack(&list, 200);
	PushBack(&list, 300);
	PushBack(&list, 400);
	PushBack(&list, 500);
	PushBack(&list, 600);
	PushBack(&list, 700);

	DestroyList(&list);

	return 0;
}