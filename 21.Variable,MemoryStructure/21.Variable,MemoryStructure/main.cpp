#include <iostream>
#include "Calculate.h"

/*
	변수의 종류 4가지
	1.지역변수
	(메모리)가 해당 코드블럭을 벗어났을때 해제가 된다.
	쓰임:해당 지역이서만 사용이 가능하다.
	2.전역변수
	프로그램을 실행할때 (메모리)가 생성 되고 종료될때 해제 된다.
	쓰임:모든 지역에서 사용이 가능하다.
	3.static변수(정적변수)
	(메모리)는 전역변수랑 같아서 프로그램을 실행할때 생성되고 종료할때 해제 된다.
	쓰임은 지역변수랑 흡사하다. 같은 지역에서만 사용이 가능하다.

	외부파일에서 접근했을때 이름은 같지만 서로 다른변수이다. 이 말은 주소가 서로 다르다는 것이다.

	4.외부변수(extern)
	외부변수라고 부르고 전역으로 쓰이면서 외부파일에서도 똑같은 공용으로 쓰는 변수이다.
	이 말은 주소가 결국 같다는 말이다.

	메모리구조
	저장되는순서 : Code -> Data(GVAR,BSS), Heap, Stack

	ROM(Read_Only Memory) = ReadOnly

	먼저 랜덤액세스부터 얘기를해볼게요
	
	Random Access Memory는 
	1.동일한 접근시간:메모리 특정위치에 접근할때 걸리는 시간이 그 위치에 상관없이 일정하다는것을 말한다
	즉,메모리의 어느주소에 있는 데이터든지 동일 한 시간안에 접근할수 있다는 것이다.
	2.효율적 데이터 처리:RAM은 CPU가 데이터를 효율적으로 읽고 쓸수 있게 하여 프로그램 실행속도를 높인다. CPU가 빠르게 접근가능 
	3.휘발성:RAM은 전원이 꺼지면 데이터가 사라지는 휘발성 메모리이다.

	비유를통한 설명
	1.RandomAccess: 책장에서 아무 책이나 바로 꺼낼수 있는상황 첫번째나 열번째나 어디서든 꺼내도 걸리는 시간은 똑같다
	2.Sequential Access : 테이프,cd같은경우에는 순차적으로 읽어줘야된다. 이런경우 특정 데이터를 찾기위해서는 처음부터 차례로 읽어나가야 하므로 , 끝에 있는 데이터를 읽기 위해서는 오랜시간이 걸린다.


	CPU가 ram에 빠르게 접근할수 있는 이유
	1.물리적 접근성 : ram은 일반적으로 cpu와 가까운 위치에 있다 반면, hdd,ssd는 상대적으로 cpu와 멀리 떨어져있다 그래서 훨씬 느리다.
	2.데이터 전송속도 : ram은 전기 신호를 이용해 데이터에 저장하고 있다 ,나노초(ns) 단위루 접근 시간이 측정된다고 한다. 반면, 디스크는 기계적인 움직임을 필요로 하며
	데이터 접근시간이 밀리초(ms)단위로 측정된다.
	3.랜덤 액세스: RAM은 걸리는시간이 위치에 상관없이 일정하다 반면,순차적 액세스는 특정 데이터를 찾기위해서 처음부터 순서대로 읽어야 된다.
	4.메모리 계층구조 : cpu내부안에 캐시 메모리(L1,L2,L3캐시)가 있느대 이메모리는 용량이 매우 작다 RAM은 이보다 큰 용량을 제공하며, 매우빠른접근속도를 제공한다
	이러한 메모리 계층구조는 CPU가 필요한 데이터를 가장 빠른 메모리에서 찾도록 설계되어있다.
	
	컴퓨터의 메모리 계층구조 
	CPU 레지스터, L1,L2,L3캐시 // RAM , SSD/HDD

	RAM(Random Access Memory) = 프로그램 실행되는 동안 필요한 정보를 저장하는 컴퓨터 메모리에다.
	RAM이란 저장된 데이터를 순차적인게 아닌 임의의 순서로 액세스 할수 있는 데이터 저장소이다. Read,Write가능

	======================메모리 영역 ===================================

	=========RAM==================
	stack 영역 - 지역변수,함수의 매개변수(컴파일 때 크기가 결정 된다)
	heap영역 - 사용자가 직접할당하고 해제 하는 공간 // malloc ,new등을 사용해서 동적할당이 되는 변수들이 heap영역에 할당 된다.
			   만약에 메모리를 사용자가 해제를 안하게 되면 메모리 릭이 생긴다(런타임때 크기가 결정됨)
			   
			   스택영역 과 힙영역은 사실상 같은 공간을 사용한다
			   그래서 영역이 클수록 힙영역이 작아지고 ,힙영역이 클 수록 스택 영역이 작아진다.
			   
			   스택 영역이  높은주소 -> 낮은주소로 할당되고
			   힙 영역이 낮은주소 -> 높은 주소로 할당된다
			   이때 자신의 영역이 상대의 영역을 침범하느 사례가 발생할수 있는데, 이를 
			   각각 스택 오버플로우 , 힙 오버플로우라고 한다.


	data영역은 크게 (GVAR,BSS)영역을 합쳐 일컫는 말이다
	bss,GVar 영역을 나뉘는 이유 
	메모리의 효율 적인 사용과프로그램의 초기화에 있다.

	bss(Block Started by Symbol)
	초기화 되지 않은 데이터 저장
	bss는 초기화 되지 않은 전역 변수와 정적변수를 저장하는 영역이다.
	변수가 초기화 되지 않은경우 0,null로 들어가게 되있다. 
	따라서 bss에 할당된 변수들은 프로그램 실행 시 메모리의 초기화에 필요한 시간자원을 절약가능하다.
	
	GVAR(Global Variable)
	전역범위의 변수를 접근가능하게 한다. (전역변수, static변수,배열,구조체 등이저장됨)
	전역변수들은 프로그램 전체에서 사용 할수 있다. 이러한 변수들은 어디에 저장되어있는지 명확한게 중요하다.
	GVAR를 사용하여 전역변수들이 BSS에 저장된것을 나타내면,
	전역변수들을 쉽게 관리하고 추적할수 있다.

	=========RAM==================

	==========ROM=================
	코드영역- 텍스트 영역이라고 부른다 사용자가 작성한 코드가 저장되는 영역이다.
	명령문들이 저장되는곳, 제어문,함수,상수들이 해당된다.
	프로그램이 실행중에 수정되지 않고 오직 읽기만 가능하다
	코드영역에 데이터는(명령어,상수등값) 프로그램이 실행 되기 전에 이미 메모리에 로드가 되어 있기때문에
	실시간으로 로드하는것이 아니기 때문에 데이터를 빠르게 읽을수 있다 
	이는 프로그램의 실행 속도를 향상 시키는데 도움이된다.
	
	
	==========ROM=================


	

	

*/

//전역변수
int data = 0;

void Func()
{
	
	int a = 0;
	data += 1;

	std::cout << "data = " << data << std::endl;
}

void StatiFunc()
{
	g_StaticNum++;
	g_StaticNum++;

	static int g_StaticNum2 = 0;	//초기화를 0으로 한번만 하고 2번째 들어올때는 건너간다. 실제 어샘블리어코드에서 해주고 있는게 있다
									//그래서 g_StaticNum2 변수는 ++을 하게되고 계속 함수를 실행하면 값이 0 으로 초기화가 되는게 아니라 값이 계속 ++되고 있는 것이다.
	g_StaticNum2++;

	std::cout << "g_StatiNum2 : " << g_StaticNum2 << std::endl;
	
	
}


int main()
{
	Func();
	
	int iNum = Add(10, 20);

	std::cout << "iNum = " << iNum << std::endl;

	g_StaticNum++;		//이 스태틱변수는 원본이 cal헤더에 있다 그래서 여기서 값을 증가 시켜도 cal에 static변수랑은 상관이없다 이유는 서로 지역이 다르다 주소가 다르기 때문이다.
	g_StaticNum++;

	StatiFunc();

	CalFun();


	//g_StaticNum2++; 스태틱의 특징 내 지역에서만 사용이 가능하기 때문에 이 변수는 StaticFunc함수에서만 접근이 가능하다.
	
	std::cout << "Main 함수의 스태틱 값 :" << g_StaticNum << std::endl;

	//둘의주소는 다르다.

	StaticAdress();
	std::cout << "Main 함수의 스태틱 주소값 : " << &g_StaticNum << std::endl;

	//extern
	ExFunc();
	ExFunc();
	ExFunc();
	ExFunc();
	ExFunc();

	g_exNum++;
	g_exNum++;

	printf("g_exNum = %d\n", g_exNum);

	//둘의 주소는 같다
	ExAddress();
	std::cout << "Main g_exNum의 주소 : " << &g_exNum << std::endl;
	

	return 0;
}