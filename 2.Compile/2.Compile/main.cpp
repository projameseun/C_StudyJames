#include <iostream>

/*
c++ 코드로 작성한 프로그램이 실제 실행파일로 만들어 지는 과정
                                    ==========컴파일 과정 ===========
실행파일이 만들어지는 과정: 전처리 -> 컴파일 -> 빌드 -> 링킹(링커)연결 -> 실행파일 생성 
                                    ==========컴파일 과정 ===========

컴파일(Compile):어떤 언어(c,c++,c#,jave등)의 코드 전체를 다른 언어(기계어)로 바꿔주는 과정이다. 그리고 이것을 자동으로 수행해주는 프로그램을 컴파일러 라고 한다.
따라서 소스코드를 실행 가능한 형태로 변환하기위해 컴파일러 또는 인터프리터와 같은 프로그램을 사용한다.
쉽게 설명을 하면 c++같이 사람이 이해할수 있는 언어(고수준 언어)를 CPU가 이해 할수 있는 언어(저서준 언어: 기계어,어샘블리어)로 번역하는 작업을 말한다.
c++언 같은경우에는 사람이 이해할수 있는데 컴퓨터는 이해할수 없다.
그래서 이걸 컴퓨터가 이해할수 있게 번역해주는 일을 컴파일이라고 말한다.

컴파일러:컴파일 작업을 해주는 프로그램을 말한다(컴퓨터가 이해 하도록 기계어로 번역해주는 프로그램)

컴파일은 엄밀히 말하자면, 어떤 프로그래밍언어로 쓰여진 소스파일을 다른프로그래밍 언어로 바꾸어주는 번역기인 셈이다.
어떤 언어a를 b로 바꾸면 그게 컴파일이다.

1.schame(언어이름)을 c언어로 번역하든지, 심지어
2.기계어를  c언어로 번역하더라도 컴파일이라고 우리는 칭할수 있다.
하지만 대개의 경우 고수준 언어를 기계어로 번역하는 프로그램을 일컫는다.

디컴파일이란?
컴파일러와 반대의 역할을 하는 컴퓨터 프로그램이다.
기계어를 사용자가 사용하는 고급언어로 변환 해주는 프로그램이다.

컴퓨터 초기에는 프로그램을 작성하기 위해서 컴퓨터위에 바로 돌아가는 기계어를 통해서 프로그래밍을 하였다.
그러나 이런 과정은 생산성,호환성,디버깅등 모든 면에서 효율적이지 않다.
그래서 고수준 언어를 작성하고 이를 번역기를 통해 기계어로 번역을 하게 되었다.
이 번역기가 바로 컴파일러라이다.

컴파일러와 비슷한 방식에 프로그램이 인터프리터이다
컴파일러는 전체 소스코드를 읽고 분석하여 기계어로 번역하는 독립적인 프로그램을 말한다.
반면, 인터프리터는 소스코드를 한 줄씩 읽고 번역하게된다.

=============컴파일러와 인터프리터의 차이점=============

1.작동방식 
컴파일러:전체 소스코드를 읽고 분석한 후에 기계어로 번역하여 실행 파일을 생성한다. 또 한 이렇게 생성된 실행파일은 독립적으로 실행될수 있으며,실행 시에는 더 이상 소스코드가 필요하지 않다.
인터프리터:소스코드를 한 줄씩 읽고 번역하여 즉시 실행합니다. 즉 소스코드를 실행하는 동안 번역과 실행이 동시에 이루어 진다.

2.실행속도
컴파일러:소스 코드를 전체적으로 분석하고 번역하기 때문에 번역과정이 좀 더 오래 걸릴수 있지만, 실행파일은 기계어로 되어 있어 실행시는 일반적으로 빠릅니다.
인터프리터:소스 코드를 한 줄씩 읽고 번역하고 즉시 실행하기 때문에 번역과정이 더 빠르지만,실행 속도는 컴파일러에 비해서 상대적으로 느릴수 있다.

3.오류발견
컴파일러:전체 소스코드를 번역하기 때문에 컴파일 과정에서 발생하는 오류를 미리 발견할수 있다.(애초에 오류가나면 실행파일이 생성되지 않는다)
인터프리터:소스 코드를 한줄 씩 실행하기 때문에 오류는 해당 줄이 실행될 때 발견 된다.

4.이식성(소프트웨어가 다른 환경 또는 플랫폼 에서 쉽게 이동하거나 실행될수 있는 능력)
컴파일러:컴파일된 실행파일은 특정 플랫폼에서 종속적(소프트웨어나 시스템이 다른 요소나 구성 요소에 의존하는 상태 모듈,라이브러리,프레임워크등을 말한다)일수 있으며, 다른 플랫폼에서 실행하기 위해서는 다시컴파일해야 할수 있다.
인터프리터:일반적으로 플랫폼에 독립적이며, 소스코드를 실행하는동안에 플랫폼에 맞게 번역되기 때문에 이식성이 좋다.

c++은 주로 컴파일러를 사용한 것이 보편적이다.
1.성능: c++은 성능에 중점을 둔 언어(메모리를 내가 직접 관리할수 있다)이며, 컴파일 된 코드는 일반적으로 더 빠르고 효율적이다. 
2.이식성:c++은 다양한 플랫폼에서 실행 될수 있는 언어지만,컴파일된 코드는 특정 플랫폼에 종속적일 수있다. 그러나 여러 플랫폼에서 동작하는 c++컴파일러들이 널리 사용되고 있으며,이식성을 유지하면서도 최적화된 코드를 생성활수 있다.
3.라이브러리및 프레임워크:c++은 다양한 라이브러리와 프레임워크가 존재하며, 이러한 것들은 컴파일된 형태로 제공된다. 이를 통해서 높은 성능과 안정성을 제공합니다.

c++은 인터프리터를 사용하지 않는다. 이는 c++언어가 컴파일러를 통해 번역되어 실행파일을 생성하는 것이 일반적인 방식이기 때문이다.
몇 가지 특수한 상황에서는 인터프리터를 통해 c++코드를 실행하는것이 가능할수도 있다.

인터프리터를 사용하는 언어
1.스크립트언어(인터프리터를 통해 실행되는 프로그래밍언어) :많은 스크립트언어들은 인터프리터를 사용하여 실행된다. 
대표적인게 python,javascript,php등이 있다.

===============컴파일러와 인터프리터의 차이점============

원칙적으로 컴파일러는 프로그램을 기계어로 바꾸기만 할뿐 바로 실행이 가능하게 하지는 않는다.
여러 소스파일에서 나온 결과문들을 합치고 라이브러리도 포함시키는등 별도의 작업을 거쳐야 실행이 가능해지는데 이를 수행하는 프로그램이 링커다.

전처리(Preprcess):컴파일을 하기전에 하는 작업들을 말한다.
프로그래머가 하나부터 열까지 모든 부분을 소스코드에 작성하지 않는다.
외부에서 제공 되는 또는 만들어진 라이브러리를 불러오거나,컴파일러의 환경을 지정해던가, 소스코드에 어떤 특정한 키워드를 만들어주거나 등 다양한 준비과정이 있다.
전처리때 하는일..
//주석
//주석제거:소스코드에 주석을 전부 제거한다. 주석은 우리만 알아 볼수 있게 남긴 내용이기 때문에 컴퓨터는 알 필요가없다.

#include 헤더파일: 컴파일러의해 다른 소스파일에 자동으로 포함된 소스코드파일이다.
#include를 만나면 해당하는 헤더파일을 찾아 헤더파일에 모든 내용을 복사해서 소스코드에 삽입한다.
일반적으로 선언을 많이 하고있다.
<>이 표시는 라이브러리 헤더파일로써 운영체제의 특별한 위치에 있다.
""이 표시는 사용자가 직접만든 디렉터리에서 헤더파일을 include 하도록 전처리기에서 지시한다.

매크로 치환및 적용:#define을 만나면 정의된 매크로를 지정하고 같은 문자열을 만나면 #define으로 된 내용을 치환한다.

#pragma:프로그램의 이식성을 위해 특수한 상황을 컴파일러에게 알려줄때 사용한다.
헤더파일이 중복될때 사용한다 그래서 일반적으로 클래스를 자동으로 만들게 되면 항상 #pragma를 확인할수 있다.

#if,#ifdef, #ifndef, #elif, #else, #endif
조건부 컴파일 지시 키워드로 컴파일러에게 소스코드의 컴파일 영역을 알려준다.
특정 조건을 만족한다면 그 부분은 컴파일이 되고, 아니면 컴파일이 되지않는다.
게임으로 예를들면
글로벌 게임은 한글,영어,중국어,일본어등 다양한 언어를 지원해야 한다.
이때 한글버전,영어버전 등 각각 버전을 만든다면 매우 비효율 적이다.

ex)
#define LANGUAGE_KOREA

#ifdef LANGUAGE_KOREA

...

#endif

#ifdef LANGUAGE_ENGLISH

...
#endif

전처리를 잘 사용하게 된다면 불필요한 소스코드를 줄여 좋은 소스코드 구성을 만드는데 도움을 줄수 있다.

컴파일때 하는 일
컴파일러가 컴파일 작업을 할때 저수준언어로 번역된 언어를 빌드를 해주면서 .obj(목적파일)라는 파일을 cpp마다 생성해준다.
그런 후에 각 .obj파일들끼리 기능을 끌어다 사용하는게 있다면 링킹을 걸어서 사용할수 있게 해준후에
최종적으로 기계어(0,1로 구성된언어)로 만들어서 실행파일을 만들어준다. 

빌드란?
개발과정에서 소스코드를 컴퓨터가 실핼할수 있는 실행파일 또는 배포가능한 형태로 변환하는 과정을 말한다.
이 과정은 보통 컴파일,링크등의 단계로 구성 된다.

빌드하는 방법 
Ctrl+ b를 사용 하여 컴파일을 하고 빌드를 해준다.
Ctrl+ f5f를 이용해서 만들어진 실행파일을 실행시켜준다 .

목적파일이란?
컴파일러가 소스 코드를 기계어로 번역하여 생성하는 중간 형태의 파일이다.
목적파일에는 컴파일된 소스코드의 기계어 표현들이 들어 있으며,일반적으로
운영체제에 따라 조금 다른다 Unix.Linux는 .o 이고 Winodws .obj로 생성된다.

목적파일에 용도
링킹,라이브러리,디버깅 

링킹:목적파일은 링커에 의해 다른 목적파일과 함께 결합되어 실행 파일로 변환 되어진다.
여러개의 목적파일이 함께 링크 되어 실행파일을 만들때, 각 목적파일은 프로그램의 일부분이 된다.
라이브러리:라이브러리 형태로도 제공된다. 라이브러리는 여러 목적파일이나 함수들을 모아 놓은것으로 다른 프로그램에서 재사용할수 있는 코드의 모음이다.
디버깅:원본 소스코드와 관련된 디버깅 정보다 포함될수 있다.

링킹과 링커의 차이
링킹(Linking) 
링킹은 소스코드를 컴파일한 후 생성된 여러개의 목적파일을 결합하여 하나의 실행파일이나 라이브러리로 만드는 과정을 의미한다.
이 과정은 각 목적파일이 참조하는 외부변수나 함수,라이브러리등을 연결하여 실행 가능한 형태의 프로그램을 만든다.

링커(Linker)
링커는 링킹과정을 수행하는 프로그램이다.

따라서 링킹은 여러개의 목적파일을 결합하여 실행파일을 만드는 과정을 의미하고, 이과정을 수행하는 프로그램이 링커다.

코드를 작성하다보면 어떤 값이 들어 있는지? 또는 어디서 오류가 났을때
중단점을 걸어서 그 위치에서 발견하거나 버그의 원인을 찾아 수정하는 과정을 디버깅이라고 한다.
F9를통해서 디버깅을 할수 있다.

라이브러리:컴퓨터에서 즉시 개발자들이 사용할수 있도록 공통적으로 사용될수 있는 특정한 기능을 모듈화 한것이다.

====모듈과 모듈화의 차이====

모듈(Module)이란?
모듈은 프로그램을 구성하는 작은 부분이며(함수,클래스등) 일반적으로 특정기능이나 작업을 수행하는 독립적인 단위를 나타낸다.
모듈은 관련된 기능을 묶어서 관리하기 쉽도록하고,코드의 재사용성과 유지보수를 높이기 위해서 사용된다.(어려운말이야지금은...)
모듈은 보통파일 단위로 구현되며,하나의 파일에는 하나 이상의 모듈이 포함될수 있다.

모듈화(Modularization)이란?
작은모듈로 분해하고, 각 모듈간의 상호작용을 최소화 하는 설계및 방법론을 의미한다.

요약해서 말하면
모듈은 프로그램을 구성하는 작은 부분이며, 모듈화는 작음모듈을 분해하고,각 모듈간의 상호작용을 최소화하여 설계한것을 의미한다.

예를들어 하나의 함수는 모듈이고 그함수가 모여서 하나의 기능을 만들게 된다면 그것이 모듈화라고 말할수 있다.

====모듈과 모듈화의 차이====


C++에서는 반드시 진입점 함수가 필요하다.
main으로 이름이 정해져있고 반드시 꼭 main함수를 만들어 줘야 한다.
main 함수 안에 작성된 코드들만 프로그램이 실행시 영향을 준다.



*/



int main()
{
	return 0;
}