#include <iostream>
#include <vector>


class ComplateBinaryTree
{
private:
	std::vector<int> m_tree;	//트리 백터

public:
	//노드삽입
	void NodeInsert(int _value)
	{
		m_tree.push_back(_value);
	}

	//부모 노드 인덱스 반환

	int GetParent(int _pIdx)
	{
		if (_pIdx == 0)
		{
			return -1;
		}
		else
		{
			return (_pIdx - 1) / 2;
		}
	}

	int GetLeft(int _idx)
	{
		int leftIdx = 2 * _idx + 1;
		return leftIdx;
	}

	int GetRight(int _idx)
	{
		int rightIdx = 2 * _idx + 2;

		return rightIdx;
	}

	void TreePrint()
	{
		for (int i = 0; i < m_tree.size(); ++i)
		{
			std::cout << m_tree[i] << std::endl;
		}
	}

public:
	int GetSize()
	{
		return m_tree.size();
	}
};



/*
	https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html  //그래프에 대한 설명
	그래프 자료구조 
	트리 자료구조
	명확하게 말하면 그래프 자료구조안에 종류중 하나가 트리구조이다 

	우리가 배운노드를 그래프에서는 정점(Vertex)라고 많이 부른다
	노드들관의 연결이 된다면 그래프라고 볼수 있다
	ex)지하철 노선도,전기회로 등..

	위에서 말했듯이 그래프 안에 트리가 있다

	싸이클... 그래프에 존재하는 모든 간선(edge)을 틍과해서 처음 정점(vertex)으로 되돌아올수 있다면 순회(Cycle)가 가능하다 

	하지만 트리는 순회가 불가능하다.
	트리는 계층관계를 표현할떄 용이하다 
	가족관계,회사조직도,탐색 등

	최상위노드를 루트노드 라고 한다
	A가 B를 가리키고 있을때 A를 B의 부모 노드 , B를 A의 자식노드라고 부른다.
	자식의 자식이 또 나올수 있고
	대표적인게 Windown폴더도 트리구조 이다 폴더의 폴더 또 폴더 느낌...

	이런 트리중에 자식을 2개로 제한 한걸 이진트리(Binary Tree) 라고 부른다 
	최대가 2개 이기때문에 자식이 있을수도 있고 없을수도 있고 한개만 있을수도 있다.

	높이 -> 루트 노드에서 말단 노드에 이르기 까지 깊이의 최대치를 말한다
	트리가 가지고 있는 최대레벨 이라고 말할수 있다
	root가 0 ,1 둘다 될수있고 이건 뭐로 정하든 상관없다

	만약에 root가 0 이라면 다음 레벨은 1 그다음 레벨은2 로 점점 늘어난다. (그림으로 설명)		
	
	부모노드가 없는 노드는 root노드가 될것이고 가장 아래 밑단에 있는 노드는 자식이 없는 노드 일것이다.

	자식이 없는 노드는 leaf node (단말노드) 라고 부른다 


	완전이진트리에 특징
	root노드로 시작해서 자식을 항상 2개로 채워나가는 트리를 말한다 
	또한 이런특징을 갖고 있는트리는 일반적으로 배열로 구현을 하게 된다.

	
	
	
	완전이진트리의 노드에 배열 인덱스를 부여

	부모가 0이면 왼쪽 자식은 1이다.

	부모가 1이면 왼쪽 자식은 3이다.
	
	부모가 2이면 왼쪽 자식은 7이다.
	
	부모가 4이면 왼쪽 자식의 인덱스는 무엇일까?
	
	부모가 N이면 왼쪽 자식은 2xN + 1이이고 오른쪽 자식은 2xN + 2 이다.
	
	그러므로, 부모가 4이면 왼쪽 자식은 9이고 오른쪽 자식은 10이다.

	규칙===> 왼쪽 자식 2 * 인덱스 +1 // 오른쪽 자식 2 * 인덱스 + 2

	역으로 부모인덱스는 ===> 자식 인덱스 -1 / 부모인덱스 하면된다 

	=============================================================
	우리가 진짜해야될거 ... 이진탐색트리
	BST ( Binary Search Tree)

	ex)만약에  1~ 1000까지 번호표가 존재한다고 가정하자
	이떄 100명의 사람에 랜덤으로 번호표를 받는다

	예를들어 2, 33,36,78,193 , 225 ... 
	이때 갑자기 193을 찾아야된다 (탐색기능) 

	배열같은경우 찾는다고 하면 최악의 경우 data가 n개있다고칠떄 n번째에 발견할수도 잇다 최악의경우
	하지만 이진탐색을 사용하게 된다면 

	우리가 225를번째사람을 찾아야 된다고 가정할때

	1~1000 중에 
	100명중에 225 사람을 찾기위해서 
	100명중 가운대인 50번째를 접근한다 
	근데 이 50번째사람은 356라고 한다 
	그럼 내가 찾아야되는 225를 찾아야되는사람은 왼쪾에 있는걸 알수잇다 
	또한 우측에 잇는사람은 비교대상에서 제외 될것이다.

	그리고 1 ~ 50에서 중간을간다 
	그럼 그중간사람은 125라고 한다 
	그럼 우린또 오른쪽에 있다는걸 알수잇고 왼쪽은 제외된다 

	또중간의 중간 점점 덜어내다보면 원한사람이 나올것이다.
	찾을때까지 절반의 절반을 잘라 낼것이다.

	이진탐색--
	★★1.데이터가 정렬되어 있어야 된다(순서대로).★★★★★★
	2.해결해야되는 데이터크기를 절반으로 줄여가면서 탐색하는 방식이다.

	데이터가 n개라고 할때  로그 2의 n이다 

	log2의 1024는 10이다 2가 1024가 될려면 몇승해야 되나?
	log10의 1000은 3이다 
	log2의 2의32승은 32다 대략(42억) 이걸 ..vector list로 ..찾다가 최악의경우 42억정도를...

	백터나 리스트는 그냥 추가 하면되지만 (재할당일어나지않는다면)
	데이터가 정렬될수잇게 자리를 잡고 있는연산을 하고잇다...
	이렇게 보면 별로인것처럼 보일수있지만 탐색에 매우 적합하다 
	데이터를 오래걸린다면 게임에 예를든다면 로딩에 손해를 본다고 볼수잇다
	로딩에대한건 느리지만찾는건 매우 빠를수잇다 탐색알고리즘을 사용한다면 
			100(root)
		<==>	<==>
	     50      300
	  <==>       <==>
	 20   30    200

	 이진탐색트리 그림 보여주기

	 중위 순회 (in order) ..이진트리에서 가장 중요한
	 1왼쪽이 가장높음 그다음 2부모 3오른쪽 

	 전위 순회 (pre order)
	 1부모가 가장 높음 그다음 2왼쪽 3오른쪽

	 후위 순위 (post order)
	 1왼쪽 2오른쪽 그다음 3부모 
*/

int main()
{
	
	ComplateBinaryTree tree;

	for (int i = 0; i < 100; ++i)
	{
		tree.NodeInsert(i);

	}

	tree.TreePrint();

	//각 노드 부모 확인
	for (int i = 0; i < tree.GetSize(); ++i)
	{
		int ileft = tree.GetLeft(i);
		int iRight = tree.GetRight(i);

		std::cout << "Node : " << i << " Left : ";

		if (ileft != -1)
		{
			std::cout << ileft;
		}
		std::cout << " Right : ";
		if (iRight != -1)
		{
			std::cout << iRight;
		}

		std::cout << std::endl;
		
	} 
	


	return 0;
}