#include <iostream>
#include <vector>
#include <map>


class ComplateBinaryTree
{
private:
	std::vector<int> m_tree;	//트리 백터

public:
	//노드삽입
	void NodeInsert(int _value)
	{
		m_tree.push_back(_value);
	}

	//부모 노드 인덱스 반환

	int GetParent(int _pIdx)
	{
		if (_pIdx == 0)
		{
			return -1;
		}
		else
		{
			return (_pIdx - 1) / 2;
		}
	}

	int GetLeft(int _idx)
	{
		int leftIdx = 2 * _idx + 1;
		return leftIdx < m_tree.size() ? leftIdx : -1;
	}

	int GetRight(int _idx)
	{
		int rightIdx = 2 * _idx + 2;

		return rightIdx < m_tree.size() ? rightIdx : -1;
	}

	void TreePrint()
	{
		//각 노드 부모 확인
		for (int i = 0; i < m_tree.size(); ++i)
		{
			std::cout << "노드 인덱스 : " << i << ", 값 : " << m_tree[i];

			int pIdx = GetParent(i);

			if (pIdx != -1)
			{
				std::cout << ",  부모 값 : " << m_tree[pIdx];
			}
			else
			{
				std::cout << " , 부모 값 : 없음 (루트노드) ";
			}

			int leftIdx = GetLeft(i);
			if (leftIdx != -1)
			{
				std::cout << ", 왼쪽 자식 값: " << m_tree[leftIdx];
			}
			else
			{
				std::cout << ", 왼쪽 자식 값: 없음";
			}

			

			int rightIdx = GetRight(i);
			if (rightIdx != -1)
			{
				std::cout << ", 오른쪽 자식 값: " << m_tree[rightIdx];
			}
			else
			{
				std::cout << ", 오른쪽 자식 값: 없음";
			}
			

			std::cout << std::endl;

		}
	}

public:
	int GetSize()
	{
		return m_tree.size();
	}
};



/*
	https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html  //그래프에 대한 설명
	그래프 자료구조 
	트리 자료구조
	명확하게 말하면 그래프 자료구조안에 종류중 하나가 트리구조이다 

	우리가 배운노드를 그래프에서는 정점(Vertex)라고 많이 부른다
	노드들관의 연결이 된다면 그래프라고 볼수 있다
	ex)지하철 노선도,전기회로 등..

	위에서 말했듯이 그래프 안에 트리가 있다

	싸이클... 그래프에 존재하는 모든 간선(edge)을 틍과해서 처음 정점(vertex)으로 되돌아올수 있다면 순회(Cycle)가 가능하다 

	하지만 트리는 순회가 불가능하다.
	트리는 계층관계를 표현할떄 용이하다 
	가족관계,회사조직도,탐색 등

	===트리===
	1.노드들의 집합 
	각 노드는 값(data)와 다른노드들을 가리키는 레퍼런스들로 구성된다 . (값 과 레퍼런스도 포함한다는거) == 노드

	2.간선(edge)
	노드와 노드를 연결하는선 구현관점에서는 레퍼런스를 의미 (node ==> data,ref,ref,ref) 를 갖고잇다 


	3.최상위노드를 루트노드 라고 한다
	A가 B를 가리키고 있을때 A를 B의 부모 노드 , 
	B를 A의 자식노드라고 부른다.
	자식의 자식이 또 나올수 있고
	
	같은 부모를 가지는 노드들 형제노드(sibling) 라고 부른다 

	부모노드를 따라 루트노드까지 올라가며 만나는 모든노드 조상노드 

	자녀노드를 따라 내려가며 만날 수 있는 모든 노드를 자손노드 라고 부른다

	내부노드: 자녀노드를 가지는 노드(branch node,inner node)

	외부노드 : 자녀가 없는 노드 (leaf node)라고 많이부르고 한국말로 단말 노드라고 한다 

	경로길이(length of path) : 경로에 있는 노드들의 수 (자신도포함)

	노드의높이(height) : 노드에서 리프노드까지의 가장긴 경로의 간선 수 (높이는 자기자신을 포함안한다)

	트리의 높이 : 루트 노드의 높이

	노드의깊이(depth) :루트 노드에서 해당 노드까지 경로의 간선(edge)수 

	트리의깊이 : 트리에 있는 노드들의 깊이중 가장 긴 깊이   트리높이==트리깊이랑 같다 

	노드의 레벨 : 노드와 루트노드 사이의 경로에서 간선(edge)의 수 
	루트 노드의 레벨은 0,1 사용자에 따라 다르다 

	노드의크기(size) : 자신을 포함한 자손 노드의수 

	대표적인게 Windown폴더도 트리구조 이다 폴더의 폴더 또 폴더 느낌...

	==트리의 특징==
	1.루트노드는 하나만 존재 
	2.사이클이 존재 하지 않음
	3.자녀노드는 하나의 부모 노드만 존재 


	이런 트리중에 자식을 2개로 제한 한걸 이진트리(Binary Tree) 라고 부른다 
	최대가 2개 이기때문에 자식이 있을수도 있고 없을수도 있고 한개만 있을수도 있다.

	높이 -> 루트 노드에서 말단 노드에 이르기 까지 깊이의 최대치를 말한다
	트리가 가지고 있는 최대레벨 이라고 말할수 있다
	root가 0 ,1 둘다 될수있고 이건 뭐로 정하든 상관없다

	만약에 root가 0 이라면 다음 레벨은 1 그다음 레벨은2 로 점점 늘어난다. (그림으로 설명)		
	
	부모노드가 없는 노드는 root노드가 될것이고 가장 아래 밑단에 있는 노드는 자식이 없는 노드 일것이다.

	자식이 없는 노드는 leaf node (단말노드) 라고 부른다 


	완전이진트리에 특징
	root노드로 시작해서 자식을 항상 2개로 채워나가는 트리를 말한다 
	마지막 레벨은 왼쪽부터 빠짐없이 노드가 채워져 있는 트리를 말한다
	또한 이런특징을 갖고 있는트리는 일반적으로 배열로 구현을 하게 된다.

	
	
	
	완전이진트리의 노드에 배열 인덱스를 부여

	부모가 0이면 왼쪽 자식은 1이다.

	부모가 1이면 왼쪽 자식은 3이다.
	
	부모가 2이면 왼쪽 자식은 7이다.
	
	부모가 4이면 왼쪽 자식의 인덱스는 무엇일까?
	
	부모가 N이면 왼쪽 자식은 2xN + 1이이고 오른쪽 자식은 2xN + 2 이다.
	
	그러므로, 부모가 4이면 왼쪽 자식은 9이고 오른쪽 자식은 10이다.

	규칙===> 왼쪽 자식 2 * 인덱스 +1 // 오른쪽 자식 2 * 인덱스 + 2

	역으로 부모인덱스는 ===> 자식 인덱스 -1 / 부모인덱스 하면된다 


	포화 이진트리 모든 레벨이 노드로 꽉 차있는 트리이다 자식이 2개로 무조건
	완전 이진트리란 모든레벨에서 노드가 가득 차있고 ,마지막 레벨에서는 노드가 왼쪽 부터 채워지는 이진트리를 말한다.

	=============================================================
	우리가 진짜해야될거 ... 이진탐색트리
	BST ( Binary Search Tree)

	ex)만약에  1~ 1000까지 번호표가 존재한다고 가정하자
	이떄 100명의 사람에 랜덤으로 번호표를 받는다

	예를들어 2, 33,36,78,193 , 225 ... 
	이때 갑자기 193을 찾아야된다 (탐색기능) 

	배열같은경우 찾는다고 하면 최악의 경우 data가 n개있다고칠떄 n번째에 발견할수도 잇다 최악의경우
	하지만 이진탐색을 사용하게 된다면 

	우리가 225를번째사람을 찾아야 된다고 가정할때

	1~1000 중에 
	100명중에 225 사람을 찾기위해서 
	100명중 가운대인 50번째를 접근한다 
	근데 이 50번째사람은 356라고 한다 
	그럼 내가 찾아야되는 225를 찾아야되는사람은 왼쪾에 있는걸 알수잇다 
	또한 우측에 잇는사람은 비교대상에서 제외 될것이다.

	그리고 1 ~ 50에서 중간을간다 
	그럼 그중간사람은 125라고 한다 
	그럼 우린또 오른쪽에 있다는걸 알수잇고 왼쪽은 제외된다 

	또중간의 중간 점점 덜어내다보면 원한사람이 나올것이다.
	찾을때까지 절반의 절반을 잘라 낼것이다.

	이진탐색--
	★★1.데이터가 정렬되어 있어야 된다(순서대로).★★★★★★
	2.해결해야되는 데이터크기를 절반으로 줄여가면서 탐색하는 방식이다.
	3.모든 노드의 왼쪽 서브트리는 해당 노드의 값보다 작은 값들만 가지고
	모든 노드의 오른쪽 서브트리는 해당 노드의 값보다 큰 값들만 가진다.
	4.이진탐색트리의 최소값은 가장왼쪽 , 최대값은 가장 오른쪽 
	5.노드의 후임자(Successor)
	해당 노드보다 값이 큰 노드들 중에서 가장 값이 작은노드
	6.노드의 선임자(predescssor)
	해당 노드보다 값이 작은 노드들 중에서 가장 값이 큰노드


	//빅오	입력			탐색
	vector	O(1)		O(N)
	list	O(1)		O(N)
	bst		0(logN)		O(logN)

	O(1) > O(logN) > O(N)

	데이터가 n개라고 할때  로그 2의 n이다 

	log2의 1024는 10이다 2가 1024가 될려면 몇승해야 되나? 10이다
	log10의 1000은 3이다 
	log2의 2의32승은 32다 대략(42억) 이걸 ..vector list로 ..찾다가 최악의경우 42억정도를...

	백터나 리스트는 그냥 추가 하면되지만 (재할당일어나지않는다면)
	데이터가 정렬될수잇게 자리를 잡고 있는연산을 하고잇다...
	이렇게 보면 별로인것처럼 보일수있지만 탐색에 매우 적합하다 
	데이터를 오래걸린다면 게임에 예를든다면 로딩에 손해를 본다고 볼수잇다
	로딩에대한건 느리지만찾는건 매우 빠를수잇다 탐색알고리즘을 사용한다면 
			100(root)
		<==>	<==>
	     50      300
	  <==>       <==>
	 20   30    200

	 이진탐색트리 그림 보여주기

	 중위 순회 (in order) ..이진트리에서 가장 중요한
	 1왼쪽이 가장높음 그다음 2부모 3오른쪽 

	 전위 순회 (pre order)
	 1부모가 가장 높음 그다음 2왼쪽 3오른쪽

	 후위 순위 (post order)
	 1왼쪽 2오른쪽 그다음 3부모 

	 중위순회가 중요한 이유 정렬되서 숫자가 나오기때문에 

	 중위후속자 - 다음노드
	 중위선행자 - 이전노드

	 이진탐색트리에 단점
	 만약에 data가 순차적으로 이루어지면 효율적이지 못할것이다
	 예를들어 1~1000을 다넣는다고하면
	 1이 root일때
	 모두 2 ,3,4,5,6,.... 1000 까지 오른쪽으로 밀릴것이다 

	 이진탐색트리는 그래서 삼각형처럼 밸런스가 잡혀잇어야
	 한쪽을 우리가 찾았을때 반을 나눌수 있다.

	 이진탐색트리 사이트 보여주기!!!

	 그래서 우리는 이진탐색트리를 사용할때 자가균형(Self Balanced)을 같이 사용한다

	 대표적인게 AVL,Red-Black 레드블랙이진트리사이트보여주고 자가균형 

	 STL에 대표적인건 map

	 우리가 만들 자료구조는 map 과비슷한 이진트리탐색이 될것이다
*/

int main()
{
	
	ComplateBinaryTree tree;

	for (int i = 0; i < 100; ++i)
	{
		tree.NodeInsert(i);

	}


	/*tree.NodeInsert(10);
	tree.NodeInsert(20);
	tree.NodeInsert(30);
	tree.NodeInsert(40);
	tree.NodeInsert(50);
	tree.NodeInsert(60);
	tree.NodeInsert(70);*/

	tree.TreePrint();

	


	


	return 0;
}